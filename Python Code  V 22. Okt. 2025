import requests
import tkinter as tk
from tkinter import messagebox, ttk
import math
# Globale Variablen
card_details_dict = {}
entry = None
main_frame = None
# Edition-Namen
EDITION_NAMES = {
    0: "Alpha", 1: "Beta", 2: "Promo", 3: "Chaos Reward", 4: "Untamed", 5: "Dice",
    6: "Gladius", 7: "Chaos Legion", 8: "Riftwatchers", 10: "Chaos Soulbound",
    12: "Rebellion", 13: "Rebellion Soulbound", 14: "Conclave", 15: "Foundation", 17: "Conclave Promo", 18: "Conclave Reward"
}
RARITY_COLORS = {1: "#d0d0d0", 2: "#87ceeb", 3: "#dda0dd", 4: "#ffd700"}
RARITY_NAMES = {1: "C", 2: "R", 3: "E", 4: "L"}
# Vereinfachte Sets - kombiniert zu Dictionaries
SPECIAL_CARDS = {
    "level_only": {
    },
    "beta_reward": {
        "Baby Unicorn", "Battle Orca", "Beetle Queen", "Black Dragon", "Boogeyman", "Brownie",
        "Creeping Ooze", "Crystal Werewolf", "Daria Dragonscale", "Divine Sorceress", "Ettin Spearman",
        "Exploding Dwarf", "Fallen Specter", "Fire Spitter", "Flame Imp", "Furious Chicken",
        "Gelatinous Cube", "Goblin Mech", "Gremlin Blaster", "Highland Archer", "Hobgoblin",
        "Imp Bowman", "Javelin Thrower", "Korjack", "Lord Arianthus", "Manticore", "Mushroom Seer",
        "Naga Fire Wizard", "Naga Windmaster", "Octopider", "Phantom Soldier", "Pirate Archer",
        "Prismatic Energy", "Ruler of the Seas", "Rusty Android", "Sacred Unicorn", "Screeching Vulture",
        "Sea Genie", "Sea Monster", "Serpentine Mystic", "Silvershield Archers", "Silvershield Assassin",
        "Skeleton Warrior", "Skeletal Warrior", "Spirit Miner", "Spirit Shaman", "The Kraken",
        "Undead Minotaur", "Vampire", "Wood Nymph", "Zalran Efreet"
    },
    "promos": {
        "alpha": {"Dragon Whelp", "Neb Seni", "Royal Dragon Archer", "Shin-Lo"},
        "beta": {
            "Archmage Arius", "Armorsmith", "Corrupted Pegasus", "Delwyn Dragonscale", "Dragon Whelp",
            "Dragonling Bowman", "Dwarven Wizard", "Electric Eels", "Enchanted Defender", "Fiendish Harpy",
            "Goblin Chef", "Lord of Fire", "Mermaid Healer", "Minotaur Warlord", "Molten Ogre",
            "Prince Julian", "Red Dragon", "Shin-Lo", "Silvershield Bard", "Undead Archer"
        },
        "untamed": {"Chain Golem", "Halfling Alchemist", "Mighty Dricken"},
        "chaos": {
            "Arkemis the Bear", "Doctor Blight", "Lux Vega", "Oshuur Constantia", "Runi",
            "Vruz", "Waka Spiritblade", "Zyriel"
        },
        "rebellion": {
            "Baron Fyatt", "Delya", "Elanor Bravefoot", "Fizbo the Fabulous", "Grimbardun Smith",
            "Henchling Enforcer", "Heloise the Hollow", "Kelan Gaines", "Mana Warden", "Mantaroth",
            "Meriput Mossmender", "Nephket", "Night Stalker", "Riklauniman", "Rune Arcanist",
            "Sanctus Vicar", "Ulfga the Blighted", "Warborn Shaman"
        },
        "conclave": {"Arcane Skinwalker", "Archmage Yabanius", "Arena Fanatic", "Gramel the Hunger", "Tasoshi Drakamoto",
                     "Yaba's Pickle", "Dar 'Gottem' Gearnut"}
    },
    "untamed_reward": {
        "Almo Cambio", "Ancient Lich", "Ant Miners", "Axemaster", "Barking Spider", "Bila The Radiant",
        "Bila the Radiant", "Captain's Ghost", "Centaur Mage", "Centauri Mage", "Chain Spinner",
        "Charlok Minotaur", "Dark Ferryman", "Demented Shark", "Efreet Elder", "Evangelist",
        "Fineas Rage", "Flame Monkey", "Gloridax Soldier", "Grim Reaper", "Harvester",
        "Kelp Initiate", "Kretch Tallevor", "Nectar Queen", "Nightmare", "Onyx Sentinel",
        "Phantasm", "Pyromancer", "Robo-Dragon Knight", "Sand Worm", "Shadowy Presence",
        "Silvershield Sheriff", "Spirit Druid Grog", "Temple Priest", "Torhilo the Frozen",
        "Tortis The Frozen", "Undead Rexx", "Warrior Of Peace", "Warrior of Peace", "Wave Runner"
    }
}
# BCX wird für alle Editionen angezeigt und berechnet
IGNORE_BCX_EDITIONS = {}  # Jetzt leer - alle Editionen zeigen BCX an
# Vereinfachte Funktionen
def get_max_bcx(rarity, gold, edition_name=None, level=None):
    if edition_name == "Foundation":
        if gold:  # Goldfoil-Karten haben immer deutlich niedrigere Max-BCX
            foundation_gold_max = {1: 5, 2: 4, 3: 2, 4: 1}  # Beispielwerte
            return foundation_gold_max.get(rarity, 1)
        else:  # Regular
            foundation_regular_max = {1: 38, 2: 22, 3: 10, 4: 3}
            return foundation_regular_max.get(rarity, 1)
    # Standard-Berechnung
    return {1: 38, 2: 22, 3: 10, 4: 4}[rarity] if gold else {1: 400, 2: 115, 3: 46, 4: 11}[rarity]
def get_progress_color(percentage):
    if percentage < 30:
        return "#ffeeee"
    elif percentage < 70:
        return "#fff4e0"
    elif percentage < 100:
        return "#eaffea"
    else:
        return "#ccffcc"
def load_card_details():
    global card_details_dict
    try:
        resp = requests.get("https://api2.splinterlands.com/cards/get_details", timeout=10)
        for card in resp.json():
            cid = int(card["id"])
            name = card.get("name", "Unbekannt")
            ed = card.get("edition", card.get("editions", 0))
            rarity = int(card.get("rarity", 1))
            # Vereinfachte Edition-Behandlung
            if isinstance(ed, (list, str)):
                ed = int(str(ed).split(',')[0]) if ',' in str(ed) else (ed[0] if isinstance(ed, list) else int(ed))
            else:
                ed = int(ed)
            card_details_dict[cid] = {"name": name, "edition": ed, "rarity": rarity}
    except Exception as e:
        messagebox.showerror("Fehler", f"Kartendetails konnten nicht geladen werden: {e}")
def classify_card_edition(name, original_edition):
    edition = EDITION_NAMES.get(original_edition, f"Edition {original_edition}")
    if original_edition in [2, 3]:
        # Prüfe Spezialsets in der Reihenfolge
        if name in SPECIAL_CARDS["beta_reward"]:
            return "Beta Reward"
        elif name in SPECIAL_CARDS["untamed_reward"]:
            return "Untamed Reward"
        elif name in SPECIAL_CARDS["promos"]["alpha"]:
            return "Alpha Promo"
        elif name in SPECIAL_CARDS["promos"]["beta"]:
            return "Beta Promo"
        elif name in SPECIAL_CARDS["promos"]["untamed"]:
            return "Untamed Promo"
        elif name in SPECIAL_CARDS["promos"]["chaos"]:
            return "Chaos Promo"
        elif name in SPECIAL_CARDS["promos"]["rebellion"]:
            return "Rebellion Promo"
        elif name in SPECIAL_CARDS["promos"]["conclave"]:
            return "Conclave Promo"
    return edition
def process_cards_data(cards):
    card_bcx_totals = {}
    final_cards = {}
    # Erste Phase: Sammle alle BCX-Daten
    for c in cards:
        cid, lvl, bcx, gold = int(c["card_detail_id"]), int(c.get("level", 1)), int(c.get("bcx", 0)), int(
            c.get("gold", 0))
        key = (cid, gold)
        if key not in card_bcx_totals:
            card_bcx_totals[key] = {"total_bcx": 0, "highest_level": 0, "gold": gold}
        card_bcx_totals[key]["total_bcx"] += bcx
        card_bcx_totals[key]["highest_level"] = max(card_bcx_totals[key]["highest_level"], lvl)
    # Zweite Phase: Bestimme beste Karte pro ID
    for (cid, gold), data in card_bcx_totals.items():
        if cid in final_cards:
            current_card = final_cards[cid]
            card_details = card_details_dict.get(cid, {})
            rarity = card_details.get("rarity", 1)
            name = card_details.get("name", "")
            original_edition = card_details.get("edition", 0)
            edition = classify_card_edition(name, original_edition)
            # BCX-Logik für alle Editionen
            current_max_bcx = get_max_bcx(rarity, current_card["gold"])
            new_max_bcx = get_max_bcx(rarity, gold)
            current_is_maxed = current_card["bcx"] >= current_max_bcx
            new_is_maxed = data["total_bcx"] >= new_max_bcx
            if current_is_maxed and new_is_maxed and gold == 1:
                final_cards[cid] = {"level": data["highest_level"], "bcx": data["total_bcx"], "gold": gold}
                continue
            elif new_is_maxed and not current_is_maxed:
                final_cards[cid] = {"level": data["highest_level"], "bcx": data["total_bcx"], "gold": gold}
                continue
            elif current_is_maxed and not new_is_maxed:
                continue
            # Standard: Höheres Level gewinnt
            if data["highest_level"] > current_card["level"]:
                final_cards[cid] = {"level": data["highest_level"], "bcx": data["total_bcx"], "gold": gold}
        else:
            final_cards[cid] = {"level": data["highest_level"], "bcx": data["total_bcx"], "gold": gold}
    return final_cards


# ==========================================================
# GUI-Komponenten
# ==========================================================
def create_combined_columns(parent, owned_cards, missing_cards, bg_color, max_cards_per_column=21,
                            show_only_not_maxed=False, show_maxed_message=True):
    """Erzeugt Spalten mit vorhandenen und fehlenden Karten."""
    # Filtern nach "Not Maxed" wenn aktiviert
    if show_only_not_maxed:
        owned_cards = [card for card in owned_cards if not card[2]]

    # Sortierung: Erst nach Seltenheit (rarity), dann nach Name
    all_cards = [("owned", *x) for x in sorted(owned_cards, key=lambda y: (y[1], y[0]))]
    all_cards += [("missing", *x, None) for x in sorted(missing_cards, key=lambda y: (y[1], y[0]))]

    if not all_cards and show_maxed_message:  # Nur anzeigen wenn erlaubt
        maxed_frame = tk.Frame(parent, bg=bg_color)
        maxed_frame.pack(expand=True, pady=20)

        tk.Label(
            maxed_frame, text="SET",
            bg=bg_color, font=("Arial", 20, "bold"),
            fg="#333"
        ).pack()

        tk.Label(
            maxed_frame, text="MAXED OUT ✓",
            bg=bg_color, font=("Arial", 20, "bold"),
            fg="#4caf50"
        ).pack()
        return

    num_columns = math.ceil(len(all_cards) / max_cards_per_column)
    for col in range(num_columns):
        start = col * max_cards_per_column
        subset = all_cards[start:start + max_cards_per_column]
        col_frame = tk.Frame(parent, bg=bg_color)
        col_frame.grid(row=0, column=col, sticky="nw", padx=2)

        for item in subset:
            ctype = item[0]
            text = item[1]
            rarity = item[2]
            is_max = item[3] if len(item) > 3 else None

            if ctype == "owned":
                color = RARITY_COLORS.get(rarity, "#ffffff")
                font = ("Arial", 9, "bold" if is_max else "normal")
                border = 2 if is_max else 0.5

                label = tk.Label(
                    col_frame, text=text, bg=color, font=font,
                    relief="solid", bd=border, anchor="w", wraplength=260,
                    padx=4, pady=2
                )

                # Goldrahmen
                if text.startswith("✨"):
                    label.config(highlightbackground="#FFB800", highlightthickness=2)

                label.pack(fill="x", pady=1)

            else:
                miss_txt = f"{text} ({RARITY_NAMES.get(rarity, '?')})"
                tk.Label(
                    col_frame, text=miss_txt, bg="#ffcccc", anchor="w",
                    font=("Arial", 9), wraplength=200, padx=4, pady=2
                ).pack(fill="x", pady=1)

def create_edition_frame(parent, name, owned, missing, stats, show_only_not_maxed=False, show_maxed_message=True):
    """Erzeugt einen Frame für eine Edition."""
    total_owned = stats.get("owned", 0)
    total_maxed = stats.get("maxed", 0)
    total_missing_bcx = stats.get("missing_bcx", 0)
    total_missing_cards = stats.get("total_missing_count", len(missing))
    total_cards = total_owned + total_missing_cards

    owned_pct = (total_owned / total_cards * 100) if total_cards else 0
    maxed_pct = (total_maxed / total_cards * 100) if total_cards else 0
    bg_color = "#8bc34a" if total_cards > 0 and total_maxed == total_cards else get_progress_color(owned_pct)

    frame = tk.Frame(parent, bg=bg_color, relief="raised", bd=1, padx=5, pady=5)

    # Titel
    tk.Label(
        frame, text=name, font=("Arial", 11, "bold"),
        bg="#2196f3", fg="white", padx=3
    ).pack(fill="x", pady=(0, 5))

    # Statistiktext
    lines = [
        f"Missing BCX: {total_missing_bcx}",
        f"Maxed Cards: {total_maxed} ({maxed_pct:.1f}%)",
        f"Owned Cards: {total_owned} ({owned_pct:.1f}%)",
        f"Missing Cards: {total_missing_cards}"
    ]
    tk.Label(
        frame, text="\n".join(lines), bg=bg_color, fg="#333",
        font=("Arial", 10, "bold"), justify="left"
    ).pack(fill="x", pady=(0, 5))

    # Fortschrittsbalken
    if total_cards > 0:
        ttk.Progressbar(frame, length=200, mode='determinate', value=owned_pct).pack(fill="x", pady=(0, 5))

    # Karten
    cards_frame = tk.Frame(frame, bg=bg_color)
    cards_frame.pack(fill="x", pady=2)
    create_combined_columns(cards_frame, owned, missing, bg_color, show_only_not_maxed=show_only_not_maxed, show_maxed_message=show_maxed_message)

    return frame

# ==========================================================
# Hauptfunktion: Karten abrufen
# ==========================================================
def fetch_cards():
    global entry, main_frame, filter_var
    username = entry.get().strip()
    if not username:
        messagebox.showwarning("Fehler", "USERNAME.")
        return

    for w in main_frame.winfo_children():
        w.destroy()

    loading = tk.Label(main_frame, text="⏳ Lade Kartendaten...", font=("Arial", 12))
    loading.pack(expand=True)
    main_frame.update()

    # Filter-Status
    show_only_not_maxed = filter_var.get()

    try:
        resp = requests.get(f"https://api2.splinterlands.com/cards/collection/{username}", timeout=15)
        cards = resp.json().get("cards", [])
        if not cards:
            loading.config(text="❌ Keine Karten gefunden.")
            return

        final_cards = process_cards_data(cards)
        edition_groups, missing_by_ed, stats_by_ed = {}, {}, {}

        for cid, details in card_details_dict.items():
            ed = details["edition"]
            if ed in [9, 11]:  # Überspringe nicht existierende
                continue

            name, rarity = details["name"], details["rarity"]
            edition = classify_card_edition(name, ed)

            if cid in final_cards:
                info = final_cards[cid]
                lvl, bcx, gold = info["level"], info["bcx"], info["gold"]
                foil = "✨" if gold else ""
                max_bcx = get_max_bcx(rarity, gold, edition)
                is_max = bcx >= max_bcx
                label = f"{foil}{name} - Level {lvl} (BCX {bcx}){' ⭐' if is_max else ''}"

                stats_by_ed.setdefault(edition, {"missing_bcx": 0, "maxed": 0, "owned": 0})
                stats_by_ed[edition]["owned"] += 1
                if is_max:
                    stats_by_ed[edition]["maxed"] += 1
                else:
                    stats_by_ed[edition]["missing_bcx"] += max_bcx - bcx

                edition_groups.setdefault(edition, []).append((label, rarity, is_max))
            else:
                missing_by_ed.setdefault(edition, []).append((name, rarity))
                stats_by_ed.setdefault(edition, {"missing_bcx": 0, "maxed": 0, "owned": 0})
                stats_by_ed[edition]["missing_bcx"] += get_max_bcx(rarity, False, edition)

        loading.destroy()

        # Scrollbare Ansicht
        canvas = tk.Canvas(main_frame, bg="#ffffff")
        v_scroll = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        h_scroll = tk.Scrollbar(main_frame, orient="horizontal", command=canvas.xview)
        canvas.configure(xscrollcommand=h_scroll.set, yscrollcommand=v_scroll.set)

        scrollable = tk.Frame(canvas, bg="#ffffff")
        scrollable.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable, anchor="nw")

        # Editionen in gewünschter Reihenfolge
        custom_order = [
            ("Alpha", "Beta"), "Alpha Promo", "Beta Promo", "Beta Reward",
            "Untamed", "Untamed Promo", "Untamed Reward", "Dice", "Chaos Legion",
            "Chaos Promo", "Chaos Reward", "Chaos Soulbound", "Riftwatchers",
            "Rebellion", "Rebellion Promo", "Rebellion Soulbound", "Conclave",
            "Conclave Promo", "Conclave Reward", "Gladius", "Foundation"
        ]

        all_eds = set(edition_groups) | set(missing_by_ed)
        used, ordered = set(), []

        for entry_item in custom_order:
            if isinstance(entry_item, tuple):
                keys = [k for k in entry_item if k in all_eds]
                if keys:
                    ordered.append(("/".join(entry_item), keys))
                    used.update(keys)
            elif entry_item in all_eds:
                ordered.append((entry_item, [entry_item]))
                used.add(entry_item)

        for ed in sorted(all_eds - used):
            ordered.append((ed, [ed]))

        col = 0
        for display, keys in ordered:
            owned = sum([edition_groups.get(k, []) for k in keys], [])
            missing = sum([missing_by_ed.get(k, []) for k in keys], [])
            stats = {
                "missing_bcx": sum(stats_by_ed[k]["missing_bcx"] for k in keys),
                "maxed": sum(stats_by_ed[k]["maxed"] for k in keys),
                "owned": sum(stats_by_ed[k]["owned"] for k in keys)
            }
            frame = create_edition_frame(scrollable, display, owned, missing, stats, show_only_not_maxed)
            frame.grid(row=0, column=col, sticky="n", padx=4, pady=4)
            col += 1

        # Gesamtübersicht
        total_stats = {
            "missing_bcx": sum(v["missing_bcx"] for v in stats_by_ed.values()),
            "maxed": sum(v["maxed"] for v in stats_by_ed.values()),
            "owned": sum(v["owned"] for v in stats_by_ed.values()),
            "total_missing_count": sum(len(missing_by_ed.get(ed, [])) for ed in missing_by_ed)
        }

        total_frame = create_edition_frame(scrollable, "Total (All Editions)", [], [], total_stats, show_only_not_maxed,show_maxed_message=False)
        total_frame.grid(row=0, column=col, sticky="n", padx=4, pady=4)

        h_scroll.pack(side="bottom", fill="x")
        v_scroll.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)

        canvas.bind_all("<MouseWheel>", lambda e: canvas.yview_scroll(int(-1 * (e.delta / 120)), "units"))

    except Exception as e:
        loading.config(text=f"❌ Fehler: {e}")


# ==========================================================
# GUI Setup
# ==========================================================
root = tk.Tk()
root.title("⚔️ Splinterlands Kartensammlung")

# Fenster maximieren
try:
    root.state('zoomed')
except:
    try:
        root.attributes('-zoomed', True)
    except:
        root.geometry(f"{root.winfo_screenwidth()}x{root.winfo_screenheight()}+0+0")

root.configure(bg="#f7f7f7")

# Header
header = tk.Frame(root, bg="#1976d2", height=60)
header.pack(fill="x")
header.pack_propagate(False)
tk.Label(
    header, text="Splinterlands Kartensammlung",
    font=("Arial", 16, "bold"), bg="#1976d2", fg="white"
).pack(expand=True)

# Eingabebereich
input_frame = tk.Frame(root, bg="#f7f7f7")
input_frame.pack(pady=10)

tk.Label(input_frame, text="Username:", bg="#f7f7f7", font=("Arial", 10, "bold")).grid(row=0, column=0, padx=5)
entry = tk.Entry(input_frame, font=("Arial", 10))
entry.grid(row=0, column=1, padx=5)
entry.bind('<Return>', lambda e: fetch_cards())

# Filter-Checkbox
filter_var = tk.BooleanVar(value=False)
filter_check = tk.Checkbutton(
    input_frame,
    text="ONLY NOT MAXED Cards",
    variable=filter_var,
    bg="#f7f7f7",
    font=("Arial", 10, "bold" ),
    command=fetch_cards  # Automatisch aktualisieren bei Klick
)
filter_check.grid(row=0, column=2, padx=5)

# Karten abrufen Button
btn = tk.Button(
    input_frame, text="Karten abrufen", command=fetch_cards,
    font=("Arial", 9, "bold"), bg="#4caf50", fg="white",
    activebackground="#66bb6a", relief="raised", bd=2, padx=8, pady=4
)
btn.grid(row=0, column=3, padx=5)

# Aktualisieren Button
refresh_btn = tk.Button(
    input_frame, text="🔄 Aktualisieren", command=fetch_cards,
    font=("Arial", 9, "bold"), bg="#2196f3", fg="white",
    activebackground="#42a5f5", relief="raised", bd=2, padx=8, pady=4
)
refresh_btn.grid(row=0, column=4, padx=5)

# Hauptbereich
main_frame = tk.Frame(root, bg="#ffffff")
main_frame.pack(fill="both", expand=True, padx=10, pady=10)

# Kartendetails laden
load_card_details()

root.mainloop()
